---
title: 快乐的 Linux 命令行 个人笔记(3)
date: 2018-8-1 21:22:59
categories: Linux
tags: 
    - Shell
    - Linux
toc: true
thumbnail: /images/TheLinuxCommandLineLearn/TheLinuxCommandLineLearn-thumbnail.png
banner: /images/TheLinuxCommandLineLearn/TheLinuxCommandLineLearn-banner.png
---

本文对应章节：
[探究操作系统](http://billie66.github.io/TLCL/book/chap04.html)

# 选项和参数

命令名经常会带有一个或多个用来更正命令行为的选项， 更进一步，选项后面会带有一个或多个参数，这些参数是命令作用的对象。所以大多数命令看起来像这样：

```bash
command -options arguments
```

大多数命令使用的选项，是由一个中划线加上一个字符组成，例如，“-l”，但是许多命令，包括来自于 GNU 项目的命令，也支持长选项，长选项由两个中划线加上一个字组成。当然， 许多命令也允许把多个短选项串在一起使用。举一个例子，`ls -lt`，ls 命令有两个选项， “l” 选项产生长格式输出，“t”选项按文件修改时间的先后来排序。
加上长选项 “–reverse”，则结果会以相反的顺序输出：`ls -lt --reverse`。

ls 命令选项

| 选项 | 长选项 | 描述 |
| --- | --- | --- |
| -a | --all | 列出所有文件，甚至包括文件名以圆点开头的默认会被隐藏的隐藏文件。 |
| -d | --directory | 通常，如果指定了目录名，ls 命令会列出这个目录中的内容，而不是目录本身。 把这个选项与 -l 选项结合使用，可以看到所指定目录的详细信息，而不是目录中的内容。 |
| -F | --classify | 这个选项会在每个所列出的名字后面加上一个指示符。例如，如果名字是 目录名，则会加上一个'/'字符。 |
| -h | --human-readable | 当以长格式列出时，以人们可读的格式，而不是以字节数来显示文件的大小。 |
| -l |  | 以长格式显示结果。 |
| -r | --reverse | 以相反的顺序来显示结果。通常，ls 命令的输出结果按照字母升序排列。 |
| -S |  | 命令输出结果按照文件大小来排序。 |
| -t |  | 按照修改时间来排序。 |

## 长格式输出研究

“-l”选项导致 ls 的输出结果以长格式输出。这种格式包含大量的有用信息。

一个 `ls -al` 的实例：

```bash
drwxr-xr-x    2 root     root          1002 Jun  8  2015 .
drwxr-xr-x    1 root     root             0 Jun  8  2015 ..
-rwxr-xr-x    1 root     root         12503 Jun  8  2015 apctrl
-rwxr-xr-x    1 root     root          2487 Jun  8  2015 askfirst
-rwxr-xr-x    1 root     root          8439 Jun  8  2015 ated
-rwxr-xr-x    1 root     root         31127 Jun  8  2015 block
-rwxrwxr-x    1 root     root         20981 Oct 23  2014 config-vlan
lrwxrwxrwx    1 root     root            14 Jun  8  2015 devmem -> ../bin/busybox
```


长格式列表的字段

| 字段 | 含义 |
| --- | --- |
| -rw-r--r-- | 对于文件的访问权限。第一个字符指明文件类型。在不同类型之间，开头的“－”说明是一个普通文件，“d”表明是一个目录。其后三个字符是文件所有者的访问权限，再其后的三个字符是文件所属组中成员的访问权限，最后三个字符是其他所有人的访问权限。|
| 1 | 文件的硬链接数目。 |
| root | 文件所有者的用户名。 |
| root | 文件所属用户组的名字。 |
| 12503 | 以字节数表示的文件大小。 |
| Jun  8  2015 | 上次修改文件的时间和日期。 |
| apctrl | 文件名。 |

# 确定文件类型

随着探究操作系统的进行，知道文件包含的内容是很有用的。我们将用 file 命令来确定文件的类型。我们之前讨论过， 在 Linux 系统中，并不要求文件名来反映文件的内容。然而，一个类似 “picture.jpg” 的文件名，我们会期望它包含 JPEG 压缩图像，但 Linux 却不这样要求它。可以这样调用 file 命令：

```bash
file filename
```

当调用 file 命令后，file 命令会打印出文件内容的简单描述。例如使用`file picture.jpg`：

```bash
picture.jpg: JPEG image data, JFIF standard 1.01
```

# 用 less 浏览文本内容

less 命令是一个用来浏览文本文件的程序。纵观 Linux 系统，有许多人类可读的文本文件。less 程序为我们检查文本文件提供了方便。

为什么我们要查看文本文件呢？ 因为许多包含系统设置的文件（叫做配置文件），是以文本格式存储的，阅读它们 可以更深入的了解系统是如何工作的。另外，许多系统所用到的实际程序（叫做脚本）也是以这种格式存储的。 在随后的章节里，我们将要学习怎样编辑文本文件以修改系统设置，还要学习编写自己的脚本文件，但现在我们只是看看它们的内容而已。
使用`less filename`来查看文本文件的内容。
一旦 less 程序运行起来，我们就能浏览文件内容了。如果文件内容多于一页，那么我们可以上下滚动文件。按下“q”键， 退出 less 程序。


less 命令

| 命令 | 行为 |
| --- | --- |
| Page UP or b | 向上翻滚一页 |
| Page Down or space | 向下翻滚一页 |
| UP Arrow | 向上翻滚一行 |
| Down Arrow | 向下翻滚一行 |
| G | 移动到最后一行 |
| 1G or g | 移动到开头一行 |
| /charaters | 向前查找指定的字符串 |
| n | 向前查找下一个出现的字符串，这个字符串是之前所指定查找的 |
| h | 显示帮助屏幕 |
| q | 退出 less 程序 |

less 程序是早期 Unix 程序 more 的改进版。less 属于”页面调度器”类程序，这些程序允许以逐页方式轻松浏览长文本文档。 more 程序只能向前翻页，而 less 程序允许前后翻页，此外还有很多其它的特性。

# 系统漫游

Linux 系统中的目录

| 目录 | 评论 |
| --- | --- |
| / | 根目录，万物起源。 |
| /bin | 包含系统启动和运行所必须的二进制程序。 |
| /boot | 包含 Linux 内核、初始 RAM 磁盘映像（用于启动时所需的驱动）和 启动加载程序。 |
| /dev | 这是一个包含设备结点的特殊目录。“一切都是文件”，也适用于设备。 在这个目录里，内核维护着所有设备的列表。 |
| /etc | 这个目录包含所有系统层面的配置文件。它也包含一系列的 shell 脚本， 在系统启动时，这些脚本会开启每个系统服务。这个目录中的任何文件应该是可读的文本文件。|
| /home | 在通常的配置环境下，系统会在/home 下，给每个用户分配一个目录。普通用户只能 在自己的目录下写文件。这个限制保护系统免受错误的用户活动破坏。 |
| /lib | 包含核心系统程序所使用的共享库文件。这些文件与 Windows 中的动态链接库相似。 |
| /lost+found | 每个使用 Linux 文件系统的格式化分区或设备，例如 ext3文件系统， 都会有这个目录。当部分恢复一个损坏的文件系统时，会用到这个目录。这个目录应该是空的，除非文件系统 真正的损坏了。 |
| /media | 在现在的 Linux 系统中，/media 目录会包含可移动介质的挂载点， 例如 USB 驱动器，CD-ROMs 等等。这些介质连接到计算机之后，会自动地挂载到这个目录结点下。 |
| /mnt | 在早些的 Linux 系统中，/mnt 目录包含可移动介质的挂载点。 |
| /opt | 这个/opt 目录被用来安装“可选的”软件。这个主要用来存储可能 安装在系统中的商业软件产品。 |
| /proc | 这个/proc 目录很特殊。从存储在硬盘上的文件的意义上说，它不是真正的文件系统。 相反，它是一个由 Linux 内核维护的虚拟文件系统。它所包含的文件是内核的窥视孔。这些文件是可读的， 它们会告诉你内核是怎样监管计算机的。 |
| /root | root 帐户的家目录。 |
| /sbin | 这个目录包含“系统”二进制文件。它们是完成重大系统任务的程序，通常为超级用户保留。 |
| /tmp | 这个/tmp 目录，是用来存储由各种程序创建的临时文件的地方。一些配置导致系统每次 重新启动时，都会清空这个目录。 |
| /usr | 在 Linux 系统中，/usr 目录可能是最大的一个。它包含普通用户所需要的所有程序和文件。 |
| /usr/bin | /usr/bin 目录包含系统安装的可执行程序。通常，这个目录会包含许多程序。 |
| /usr/lib | 包含由/usr/bin 目录中的程序所用的共享库。 |
| /usr/local | 这个/usr/local 目录，是非系统发行版自带程序的安装目录。 通常，由源码编译的程序会安装在/usr/local/bin 目录下。新安装的 Linux 系统中会存在这个目录， 并且在管理员安装程序之前，这个目录是空的。 |
| /usr/sbin | 包含许多系统管理程序。 |
| /usr/share | /usr/share 目录包含许多由/usr/bin 目录中的程序使用的共享数据。 其中包括像默认的配置文件、图标、桌面背景、音频文件等等。 |
| /usr/share/doc | 大多数安装在系统中的软件包会包含一些文档。在/usr/share/doc 目录下， 我们可以找到按照软件包分类的文档。 |
| /var | 除了/tmp 和/home 目录之外，相对来说，目前我们看到的目录是静态的，这是说， 它们的内容不会改变。/var 目录存放的是动态文件。各种数据库，假脱机文件， 用户邮件等等，都位于在这里。 |
| /var/log | 这个/var/log 目录包含日志文件、各种系统活动的记录。这些文件非常重要，并且 应该时时监测它们。其中最重要的一个文件是/var/log/messages。注意，为了系统安全，在一些系统中， 你必须是超级用户才能查看这些日志文件。 |

有趣的文件：

*   /boot/grub/grub.conf or menu.lst， 被用来配置启动加载程序。
*   /boot/vmlinuz，Linux 内核。
*   /etc/crontab， 定义自动运行的任务。
*   /etc/fstab，包含存储设备的列表，以及与他们相关的挂载点。
*   /etc/passwd，包含用户帐号列表。

# 符号链接

在上面 ls -al 的实例中，我们发现了一个信息

```bash
lrwxrwxrwx    1 root     root            14 Jun  8  2015 devmem -> ../bin/busybox
```

为何这条信息第一个字符是“l”，并且有两个文件名呢？ 这是一个特殊文件，叫做符号链接（也称为软链接或者 symlink ）。 在大多数“类 Unix” 系统中， 有可能一个文件被多个文件名所指向。虽然这种特性的意义并不明显，但它真的很有用。

描绘一下这样的情景：

>一个程序要求使用某个包含在名为“foo”文件中的共享资源，但是“foo”经常改变版本号。 
这样，在文件名中包含版本号，会是一个好主意，因此管理员或者其它相关方，会知道安装了哪个“foo”版本。
这会导致另一个问题。如果我们更改了共享资源的名字，那么我们必须跟踪每个可能使用了 这个共享资源的程序，当每次这个资源的新版本被安装后，都要让使用了它的程序去寻找新的资源名。 这听起来很没趣。

这就是符号链接存在至今的原因。比方说，我们安装了文件 “foo” 的 2.6 版本，它的 件名是 “foo-2.6”，然后创建了叫做 “foo” 的符号链接，这个符号链接指向 “foo-2.6”。 
这意味着，当一个程序打开文件 “foo” 时，它实际上是打开文件 “foo-2.6”。 现在，每个人都很高兴。依赖于 “foo” 文件的程序能找到这个文件，并且我们能知道安装了哪个文件版本。
当升级到 “foo-2.7” 版本的时候，仅添加这个文件到文件系统中，删除符号链接 “foo”， 创建一个指向新版本的符号链接。这不仅解决了版本升级问题，而且还允许在系统中保存两个不同的文件版本。
假想 “foo-2.7” 有个错误，那我们得回到原来的版本。 一样的操作，我们只需要删除指向新版本的符号链接，然后创建指向旧版本的符号链接就可以了。

__拓展阅读__

完整的 Linux 文件系统层次体系标准可通过以下链接找到：
http://www.pathname.com/fhs/

